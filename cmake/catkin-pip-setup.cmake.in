#
# This script is in charge of doing the pip setup in a workspace.
# It will be configured by cmake and dropped in devel or install workspace
# where is will setup a workspace emulation of virtualenvs
#

message(STATUS "Loading ${CMAKE_CURRENT_LIST_FILE}... ")

# Make sure the atkin python package directory for the workspace is in python path
# this is only needed if the user didn't source the current workspace setup.bash (happens the first time)
string(FIND "$ENV{PYTHONPATH}" @CONFIGURE_PREFIX@/${CATKIN_GLOBAL_PYTHON_DESTINATION} FOUND_PPATH)
if ( FOUND_PPATH LESS 0 )
    set(ENV{PYTHONPATH} "@CONFIGURE_PREFIX@/${CATKIN_GLOBAL_PYTHON_DESTINATION}:$ENV{PYTHONPATH}")
endif()

# Make sure the pip target directory for the workspace is in python path
# this is only needed if the user didn't source the current workspace setup.bash (happens the first time)
string(FIND "$ENV{PYTHONPATH}" @CONFIGURE_PREFIX@/@CATKIN_PIP_GLOBAL_PYTHON_DESTINATION@ FOUND_PPPATH)
if ( FOUND_PPPATH LESS 0 )
    set(ENV{PYTHONPATH} "@CONFIGURE_PREFIX@/@CATKIN_PIP_GLOBAL_PYTHON_DESTINATION@:$ENV{PYTHONPATH}")
endif()

# Make sure the bin target directory for the workspace is in system path
# this is only needed if the user didn't source the current workspace setup.bash (happens the first time)
string(FIND "$ENV{PATH}" @CONFIGURE_PREFIX@/${CATKIN_GLOBAL_BIN_DESTINATION} FOUND_SPATH)
if ( FOUND_SPATH LESS 0 )
    set(ENV{PATH} "@CONFIGURE_PREFIX@/${CATKIN_GLOBAL_BIN_DESTINATION}:$ENV{PATH}")
endif()

message(STATUS "Catkin pip PYTHONPATH : $ENV{PYTHONPATH}")
message(STATUS "Catkin pip PATH : $ENV{PATH}")

# Note : this is obviously not changing anything in the shell environment where cmake was started from.
# And WE DO NOT WANT to do it there. The user controls his bash environment independently of what runs in it.


# Note : we need to install our fixups as normal requirements

macro(catkin_pip_requirements_prefix requirements_txt )
    message(STATUS "    ... Retrieving Pip requirements ${requirements_txt} into @CONFIGURE_PREFIX@...")

    execute_process(
      COMMAND ${CATKIN_PIP} install -r ${requirements_txt} --ignore-installed --prefix "@CONFIGURE_PREFIX@"
      WORKING_DIRECTORY @CMAKE_CURRENT_SOURCE_DIR@
      RESULT_VARIABLE PIP_RESULT
      OUTPUT_VARIABLE PIP_VARIABLE
      ERROR_VARIABLE PIP_ERROR
    )

    message(STATUS "    ... Done ... [${PIP_RESULT}]: ${PIP_VARIABLE}")
    if (PIP_RESULT)
        message(STATUS "Command ${CATKIN_PIP} install -r ${requirements_txt} --ignore-installed --prefix \"@CONFIGURE_PREFIX@\" FAILED")
        message(FATAL_ERROR "${PIP_ERROR}")
    endif()
endmacro()

macro(catkin_pip_package_prefix package_path)
    string(REPLACE ";" " " PIP_PACKAGE_INSTALL_CMDSTR "@PIP_PACKAGE_INSTALL_COMMAND@")
    message(STATUS "    ... Running ${PIP_PACKAGE_INSTALL_CMDSTR} ...")

    execute_process(
      COMMAND @PIP_PACKAGE_INSTALL_COMMAND@
      WORKING_DIRECTORY @CMAKE_CURRENT_SOURCE_DIR@
      RESULT_VARIABLE PIP_RESULT
      OUTPUT_VARIABLE PIP_VARIABLE
      ERROR_VARIABLE PIP_ERROR
    )

    message(STATUS "    ... Done ... [${PIP_RESULT}]: ${PIP_VARIABLE}")
    if (PIP_RESULT)
        message(STATUS "Command ${PIP_PACKAGE_INSTALL_CMDSTR} FAILED !")
        message(FATAL_ERROR "${PIP_ERROR}")
    endif()
endmacro()


# Trying to find our own pip
# Careful this creates a CACHE variable
find_program(CATKIN_PIP NAMES pip pip2 pip2.7 PATHS @CONFIGURE_PREFIX@/@CATKIN_GLOBAL_BIN_DESTINATION@ NO_DEFAULT_PATH)

if (CATKIN_PIP)
    message(STATUS "    ... Catkin pip was found at ${CATKIN_PIP} ...")
else ()
    # If not found, it means we need to do the whole setup...
    unset(CATKIN_PIP CACHE)
    message(STATUS "    ... Catkin pip was not found in @CONFIGURE_PREFIX@/@CATKIN_GLOBAL_BIN_DESTINATION@ ...")
    # Assuming Ubuntu Trusty here. platform detection is another hurdle
    set(CMAKE_SYSTEM_PREFIX_PATH / /usr /usr/local)
    find_program(CATKIN_SYS_PIP NAMES pip pip2 pip2.7 NO_CMAKE_PATH NO_CMAKE_ENVIRONMENT_PATH NO_SYSTEM_ENVIRONMENT_PATH)  # we need to make sure we don't find any other catkin-pip from somewhere else if our path is not clean (careful with underlays or install/devel)
    if(NOT CATKIN_SYS_PIP)
        message( FATAL_ERROR "pip system command not found. Make sure you have installed the python-pip package on your system.")
    endif()

    message(STATUS "    ... Retrieving catkin_pure_python requirements using system pip ...")

    # We need to find a pip command that works for old pip versions (indigo supports trusty which is pip v1.5.4)
    # Note --target here means we cannot check if a package is already installed or not before installing, using old pip.
    # which means we have to reinstall dependencies everytime and specify --exists-action w to avoid "already exists" errors
    # Avoid --install-option since the setuptools version found will be different the first time and the following times
    execute_process(
      COMMAND ${CATKIN_SYS_PIP} -q install -r "@CATKIN_PIP_REQUIREMENTS_PATH@/catkin-pip-base.req" --download-cache "${CMAKE_BINARY_DIR}/pip-cache" --target "@CONFIGURE_PREFIX@/@CATKIN_PIP_GLOBAL_PYTHON_DESTINATION@" --exists-action w
      WORKING_DIRECTORY @CMAKE_CURRENT_SOURCE_DIR@
      RESULT_VARIABLE PIP_RESULT
      OUTPUT_VARIABLE PIP_VARIABLE
      ERROR_VARIABLE PIP_ERROR
    )

    message(STATUS "    ... Done ... [${PIP_RESULT}]: ${PIP_VARIABLE}")
    if (PIP_RESULT)
        message(STATUS "Command ${CATKIN_SYS_PIP} install -r \"@CATKIN_PIP_REQUIREMENTS_PATH@/catkin-pip-base.req\" --download-cache \"${CMAKE_BINARY_DIR}/pip-cache\" --target \"@CONFIGURE_PREFIX@/@CATKIN_PIP_GLOBAL_PYTHON_DESTINATION@\" --exists-action w FAILED")
        message(FATAL_ERROR "${PIP_ERROR}")
    endif()

    set(CATKIN_PIP python -m pip)  # to make sure we use our recently downloaded pip version (its entrypoints were not installed by old pip/setuptools)
    unset(CATKIN_SYS_PIP CACHE)  # we dont need this any longer

    # Fixing security since python 2.7.6 on trusty is broken : https://stackoverflow.com/questions/29099404/ssl-insecureplatform-error-when-using-requests-package
    catkin_pip_requirements_prefix("@CATKIN_PIP_REQUIREMENTS_PATH@/catkin-pip-fixups.req")

    unset(CATKIN_PIP)
    # now we can finally use the simple "pip" entry_point (forcing cmake to find it)
    find_program( CATKIN_PIP NAMES pip pip2 pip2.7 PATHS @CONFIGURE_PREFIX@/@CATKIN_GLOBAL_BIN_DESTINATION@ NO_DEFAULT_PATH)
    if (CATKIN_PIP)
        message( STATUS "Found catkin_pure_python pip command at ${CATKIN_PIP}.")
    else()
        message( FATAL_ERROR "catkin_pure_python pip command not found in @CONFIGURE_PREFIX@/@CATKIN_GLOBAL_BIN_DESTINATION@. Make sure you have installed the pip pip package on @CONFIGURE_PREFIX@ workspace.")
    endif()

    # Providing another catkin nosetests usage...
    # now we can finally use the simple "nosetests" entry_point (forcing cmake to find it)
    find_program( PIP_NOSETESTS NAMES nosetests PATHS @CONFIGURE_PREFIX@/@CATKIN_GLOBAL_BIN_DESTINATION@ NO_DEFAULT_PATH)
    if(PIP_NOSETESTS)
        message( STATUS "Found catkin_pure_python nosetests command at ${PIP_NOSETESTS}.")
    else()
        message( FATAL_ERROR "catkin_pure_python nosetests command not found in @CONFIGURE_PREFIX@/@CATKIN_GLOBAL_BIN_DESTINATION@. Make sure you have installed the nose pip package on your @CONFIGURE_PREFIX@ workspace.")
    endif()

endif()